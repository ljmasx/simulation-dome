<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
    <title>DOME Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&amp;display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,1,0" rel="stylesheet">
    <!-- Vercel Web Analytics -->
    <script>
      window.va = window.va || function () { (window.vaq = window.vaq || []).push(arguments); };
    </script>
    <script defer src="/_vercel/insights/script.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #0f172a; font-family: 'Inter', sans-serif; user-select: none; }
        #canvas-container { width: 100vw; height: 100vh; display: block; position: absolute; top: 0; left: 0; z-index: 0; }
        
        .cursor-pointer { cursor: pointer; }

        /* UI Overlay */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; z-index: 10;
        }

        .divider {
            position: absolute; left: 35%; top: 0; bottom: 0; width: 2px;
            background: linear-gradient(to bottom, transparent, rgba(255,255,255,0.2), transparent);
            z-index: 10;
        }

        .control-bar {
            position: absolute; bottom: 2rem; left: 50%; transform: translateX(-50%);
            background: rgba(15, 23, 42, 0.9); backdrop-filter: blur(12px);
            padding: 1rem 2rem; border-radius: 1rem;
            border: 1px solid rgba(255,255,255,0.1);
            display: flex; gap: 1rem; pointer-events: auto;
            z-index: 20; box-shadow: 0 20px 40px -5px rgba(0, 0, 0, 0.6);
        }

        .phase-btn {
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            width: 100px; padding: 0.75rem; border-radius: 0.5rem;
            background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.05);
            color: #64748b; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
        }
        .phase-btn:hover { background: rgba(255,255,255,0.08); color: white; transform: translateY(-4px); }
        .phase-btn.active {
            background: #2563eb; color: white; border-color: #60a5fa;
            box-shadow: 0 0 20px rgba(37, 99, 235, 0.4); transform: translateY(-4px);
        }
        .phase-btn .icon { font-size: 24px; margin-bottom: 6px; }
        .phase-btn .label { font-size: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; }

        .viewport-title {
            position: absolute; top: 2rem; font-weight: 800; color: rgba(255,255,255,0.3);
            text-transform: uppercase; letter-spacing: 3px; font-size: 0.75rem;
        }

        .handle-tag {
            position: absolute; background: rgba(15, 23, 42, 0.9); color: white;
            padding: 6px 10px; border-radius: 6px; font-size: 11px;
            pointer-events: none;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s;
        }
        
        .click-hint {
            position: absolute; bottom: 15%; left: 17.5%; transform: translateX(-50%);
            color: #fff; font-size: 12px; font-weight: 600;
            background: #2563eb; padding: 4px 12px; border-radius: 20px;
            box-shadow: 0 0 15px rgba(37,99,235,0.5);
            opacity: 0; transition: opacity 0.5s;
            pointer-events: none;
        }

        .download-btn {
            position: absolute; bottom: 2rem; right: 2rem; pointer-events: auto;
            background: #0f172a; color: #64748b; font-size: 12px;
            padding: 8px 16px; border-radius: 8px; border: 1px solid #1e293b;
            cursor: pointer; transition: all 0.2s;
        }
        .download-btn:hover { color: white; border-color: #475569; }

        /* Login Screen */
        #login-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            display: flex; align-items: center; justify-content: center;
            z-index: 1000; transition: opacity 0.5s, visibility 0.5s;
        }
        #login-screen.hidden { opacity: 0; visibility: hidden; pointer-events: none; }
        .login-box {
            background: rgba(15, 23, 42, 0.9); backdrop-filter: blur(20px);
            padding: 3rem; border-radius: 1.5rem; border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            text-align: center; min-width: 320px;
        }
        .login-box img { height: 80px; margin-bottom: 1.5rem; }
        .login-box h1 { color: white; font-size: 1.5rem; font-weight: 800; margin-bottom: 0.5rem; }
        .login-box p { color: #64748b; font-size: 0.875rem; margin-bottom: 2rem; }
        .login-box input {
            width: 100%; padding: 0.875rem 1rem; border-radius: 0.5rem;
            border: 1px solid #334155; background: #1e293b; color: white;
            font-size: 1rem; margin-bottom: 1rem; outline: none;
            transition: border-color 0.2s;
        }
        .login-box input:focus { border-color: #2563eb; }
        .login-box input::placeholder { color: #64748b; }
        .login-box button {
            width: 100%; padding: 0.875rem; border-radius: 0.5rem;
            background: #2563eb; color: white; font-weight: 600;
            border: none; cursor: pointer; font-size: 1rem;
            transition: background 0.2s, transform 0.2s;
        }
        .login-box button:hover { background: #1d4ed8; transform: translateY(-2px); }
        .login-error {
            color: #f87171; font-size: 0.875rem; margin-top: 1rem;
            opacity: 0; transition: opacity 0.3s;
        }
        .login-error.show { opacity: 1; }
        .org-badge {
            display: inline-block; padding: 0.25rem 0.75rem; border-radius: 1rem;
            background: rgba(37, 99, 235, 0.2); border: 1px solid rgba(37, 99, 235, 0.3);
            color: #60a5fa; font-size: 0.75rem; font-weight: 600;
            margin-top: 1.5rem; opacity: 0; transition: opacity 0.3s;
        }
        .org-badge.show { opacity: 1; }
    </style>
</head>
<body>

<!-- Login Screen -->
<div id="login-screen">
    <div class="login-box">
        <img src="logo.svg" alt="DOME Logo">
        <h1>DOME Simulator</h1>
        <p>Enter your access code to continue</p>
        <p style="color: #475569; font-size: 0.75rem; margin-top: -1rem; margin-bottom: 1.5rem;">Polypus Holding — Confidential</p>
        <input type="password" id="password-input" placeholder="Access code" autocomplete="off">
        <button onclick="checkAccess()">Access Simulator</button>
        <div class="login-error" id="login-error">Invalid access code</div>
        <div class="org-badge" id="org-badge"></div>
    </div>
</div>

<div id="canvas-container"></div>

<div id="ui-layer">
    <div class="divider"></div>
    <div class="viewport-title" style="left: 2rem;">Operator Handles (Interactive)</div>
    <div class="viewport-title" style="left: 37%;">Endoscopic View</div>
    
    <div class="click-hint" id="click-hint">CLICK HANDLES TO OPERATE</div>
    
    <div class="handle-tag" id="tag-A" style="top: 10%; left: 6%; border-left: 3px solid #ff0000;">
        <div class="text-xs text-gray-400 font-semibold mb-0.5">HANDLE A</div>
        <div class="font-bold text-red-500">VERTICAL ARCH</div>
    </div>
    <div class="handle-tag" id="tag-B" style="top: 10%; left: 21%; border-left: 3px solid #3b82f6;">
        <div class="text-xs text-gray-400 font-semibold mb-0.5">HANDLE B</div>
        <div class="font-bold text-blue-400">HORIZONTAL MESH</div>
    </div>

    <div class="control-bar">
        <button class="phase-btn" id="btn-1" onclick="triggerPhase(1)">
            <span class="material-symbols-outlined icon">play_arrow</span>
            <span class="label">1. Deploy</span>
        </button>
        <button class="phase-btn" id="btn-2" onclick="triggerPhase(2)">
            <span class="material-symbols-outlined icon">open_in_full</span>
            <span class="label">2. Capture</span>
        </button>
        <button class="phase-btn" id="btn-3" onclick="triggerPhase(3)">
            <span class="material-symbols-outlined icon">shopping_bag</span>
            <span class="label">3. Carry</span>
        </button>
        <button class="phase-btn" id="btn-4" onclick="triggerPhase(4)">
            <span class="material-symbols-outlined icon">close_fullscreen</span>
            <span class="label">4. Release</span>
        </button>
        <button class="phase-btn active" id="btn-5" onclick="triggerPhase(5)">
            <span class="material-symbols-outlined icon">exit_to_app</span>
            <span class="label">5. Withdraw</span>
        </button>
    </div>

    <div class="absolute top-8 right-8 w-72 p-5 rounded-xl border border-slate-700 bg-slate-900/90 backdrop-blur-xl shadow-2xl">
        <div class="flex items-center justify-between mb-2">
            <div class="flex items-center gap-3">
                <img src="logo.svg" alt="DOME Logo" class="h-10 w-auto">
                <h2 class="text-xl font-bold text-white tracking-tight">DOME</h2>
            </div>
            <div class="px-2 py-0.5 rounded bg-blue-900/30 border border-blue-500/30 text-[10px] text-blue-300 font-bold uppercase tracking-wider">Simulator</div>
        </div>
        <div class="text-xs text-gray-400 mb-6 font-medium">Interactive Demo: Click handles to operate.</div>
        <div class="space-y-4">
            <div>
                <div class="text-[10px] uppercase text-gray-500 font-bold tracking-widest mb-1">Current Phase</div>
                <div class="text-lg font-bold text-white transition-all duration-300" id="status-title">5. WITHDRAW</div>
            </div>
            <div>
                <div class="text-[10px] uppercase text-gray-500 font-bold tracking-widest mb-1">Mechanism Action</div>
                <div class="text-sm text-gray-300 leading-relaxed" id="status-desc">System retracted.</div>
            </div>
        </div>
    </div>

    <button class="download-btn" onclick="downloadSource()">
        <span class="material-symbols-outlined" style="font-size: 16px; vertical-align: middle; margin-right:4px;">download</span>
        Download HTML
    </button>
</div>

<script>
    // --- AUTHENTICATION SYSTEM (via Vercel API) ---
    // Vérifier si déjà authentifié
    const savedSession = sessionStorage.getItem('dome-auth');
    if (savedSession) {
        document.getElementById('login-screen').classList.add('hidden');
    }

    async function checkAccess() {
        const input = document.getElementById('password-input');
        const error = document.getElementById('login-error');
        const badge = document.getElementById('org-badge');
        const button = document.querySelector('.login-box button');
        const password = input.value.trim();

        if (!password) return;

        // Désactiver le bouton pendant la requête
        button.disabled = true;
        button.textContent = 'Verifying...';

        try {
            const response = await fetch('/api/auth', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ password })
            });

            const data = await response.json();

            if (data.success) {
                sessionStorage.setItem('dome-auth', data.organization);
                badge.textContent = data.organization;
                badge.classList.add('show');
                error.classList.remove('show');

                setTimeout(() => {
                    document.getElementById('login-screen').classList.add('hidden');
                }, 800);
            } else {
                error.classList.add('show');
                input.value = '';
                input.focus();
            }
        } catch (err) {
            error.textContent = 'Connection error';
            error.classList.add('show');
        } finally {
            button.disabled = false;
            button.textContent = 'Access Simulator';
        }
    }

    // Enter key pour soumettre
    document.getElementById('password-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') checkAccess();
    });

    // --- SCENE SETUP ---
    const container = document.getElementById('canvas-container');
    
    // SAFETY: Ensure container is empty (removes ghost canvas from Save As)
    container.innerHTML = '';

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    container.appendChild(renderer.domElement);

    const sceneL = new THREE.Scene();
    sceneL.background = new THREE.Color(0x111827); 
    const sceneR = new THREE.Scene();
    sceneR.background = new THREE.Color(0x0f172a); 

    const cameraL = new THREE.PerspectiveCamera(35, (window.innerWidth * 0.35) / window.innerHeight, 0.1, 100);
    cameraL.position.set(0, 1, 28);
    cameraL.lookAt(0, -1, 0);

    const cameraR = new THREE.PerspectiveCamera(45, (window.innerWidth * 0.65) / window.innerHeight, 0.1, 100);
    cameraR.position.set(10, 5, 12);
    cameraR.lookAt(2, 0, 0);

    function setupLights(scene, intensity = 1) {
        const amb = new THREE.AmbientLight(0xffffff, 0.6 * intensity);
        scene.add(amb);
        const main = new THREE.DirectionalLight(0xffffff, 1.2 * intensity);
        main.position.set(5, 10, 10);
        main.castShadow = true;
        scene.add(main);
        const rim = new THREE.SpotLight(0x3b82f6, 2 * intensity);
        rim.position.set(-10, 5, -5);
        rim.lookAt(0,0,0);
        scene.add(rim);
    }
    setupLights(sceneL, 1.0);
    setupLights(sceneR, 1.2);

    // --- LEFT SCENE (HANDLES) ---
    const plasticMat = new THREE.MeshStandardMaterial({ color: 0x1f2937, roughness: 0.6, metalness: 0.1 });
    const interactables = [];

    function createHandle(xPos, color, name) {
        const group = new THREE.Group();
        group.position.x = xPos;
        
        // Shaft
        group.add(new THREE.Mesh(new THREE.BoxGeometry(0.6, 14, 0.4), plasticMat));
        const groove = new THREE.Mesh(new THREE.PlaneGeometry(0.2, 12), new THREE.MeshStandardMaterial({ color: 0x000000 }));
        groove.position.z = 0.21; group.add(groove);
        
        // Marks
        for(let i=0; i<9; i++) {
            const m = new THREE.Mesh(new THREE.PlaneGeometry(0.3, 0.04), new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.4, transparent: true }));
            m.position.z = 0.211; m.position.y = -3 + (i * 0.8);
            group.add(m);
        }

        // Thumb
        const thumb = new THREE.Group(); thumb.position.y = -7.5;
        thumb.add(new THREE.Mesh(new THREE.TorusGeometry(0.8, 0.15, 16, 32), plasticMat));
        const neck = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 1, 16), plasticMat);
        neck.position.y = 0.8; thumb.add(neck);
        group.add(thumb);

        // Slider
        const slider = new THREE.Group();
        const hitBox = new THREE.Mesh(new THREE.BoxGeometry(3.5, 2.5, 1), new THREE.MeshBasicMaterial({ visible: false }));
        hitBox.userData = { name: name }; slider.add(hitBox); interactables.push(hitBox);

        const block = new THREE.Mesh(new THREE.BoxGeometry(1.4, 1.2, 0.8), new THREE.MeshStandardMaterial({ color: color, roughness: 0.3, metalness: 0.2 }));
        slider.add(block);
        const ringGeo = new THREE.TorusGeometry(0.7, 0.14, 16, 32);
        const ringMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.3, metalness: 0.1 });
        const r1 = new THREE.Mesh(ringGeo, ringMat); r1.position.x = -1.1; slider.add(r1);
        const r2 = new THREE.Mesh(ringGeo, ringMat); r2.position.x = 1.1; slider.add(r2);
        
        group.add(slider);
        sceneL.add(group);
        return { slider, group };
    }
    const handleA = createHandle(-2.5, 0xff0000, 'A');
    const handleB = createHandle(2.5, 0x3b82f6, 'B');

    // --- RIGHT SCENE (BASKET) ---
    const basketGroup = new THREE.Group();
    sceneR.add(basketGroup);

    // Sheath
    const sheath = new THREE.Mesh(new THREE.CylinderGeometry(0.65, 0.65, 12, 32), new THREE.MeshPhysicalMaterial({ color: 0x94a3b8, transparent: true, opacity: 0.4, transmission: 0.5, roughness: 0.2, metalness: 0.5 }));
    sheath.rotation.z = Math.PI/2; sheath.position.x = -6;
    sceneR.add(sheath);

    // --- ORGANIC POLYP ---
    const polypGeo = new THREE.IcosahedronGeometry(1.2, 8);
    const polypMat = new THREE.MeshPhysicalMaterial({
        color: 0xd46868, emissive: 0x330000,
        roughness: 0.3, metalness: 0.1,
        clearcoat: 0.8, clearcoatRoughness: 0.2
    });
    const pos = polypGeo.attributes.position;
    const v = new THREE.Vector3();
    for(let i=0; i<pos.count; i++){
        v.fromBufferAttribute(pos, i);
        const noise = Math.sin(v.x * 2) * Math.sin(v.y * 2) * Math.sin(v.z * 2);
        const disp = 1 + (noise * 0.15) + (Math.random() * 0.05);
        v.multiplyScalar(disp);
        pos.setXYZ(i, v.x, v.y, v.z);
    }
    polypGeo.computeVertexNormals();
    
    const specimen = new THREE.Mesh(polypGeo, polypMat);
    const specimenGroup = new THREE.Group();
    specimenGroup.position.set(2.7, -6, 0); // Start low (like after release/before capture)
    specimenGroup.visible = false; // Initially hidden if starting withdrawn
    specimenGroup.add(specimen);
    sceneR.add(specimenGroup);

    // --- BASKET STRUCTURES ---
    const archMat = new THREE.MeshStandardMaterial({ 
        color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.4, 
        metalness: 0.9, roughness: 0.1 
    });
    const archMesh = new THREE.Mesh(new THREE.BufferGeometry(), archMat);
    basketGroup.add(archMesh);

    const wireMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.8, roughness: 0.3 });
    const loopL = new THREE.Mesh(new THREE.BufferGeometry(), wireMat);
    const loopR = new THREE.Mesh(new THREE.BufferGeometry(), wireMat);
    basketGroup.add(loopL); basketGroup.add(loopR);

    // NET MESH
    const netMat = new THREE.MeshBasicMaterial({ 
        color: 0xffffff, wireframe: true, transparent: true, opacity: 0.4, side: THREE.DoubleSide
    });
    const netMeshL = new THREE.Mesh(new THREE.BufferGeometry(), netMat);
    const netMeshR = new THREE.Mesh(new THREE.BufferGeometry(), netMat);
    basketGroup.add(netMeshL); basketGroup.add(netMeshR);

    // --- STATE & PHYSICS ---
    const state = { hVert: 0, hHoriz: 0, deploy: 0, isEjected: false };
    const REST_Y = 1.3;
    const LOW_Y = -6.0; // Ejected/Low position
    let currentPhase = 5; // Track current phase for CARRY drag feature

    // --- CARRY DRAG SYSTEM ---
    // Groupe pour déplacer ensemble cathéter + DOME + polype
    const catheterAssembly = new THREE.Group();
    sceneR.remove(sheath);
    sceneR.remove(basketGroup);
    sceneR.remove(specimenGroup);
    catheterAssembly.add(sheath);
    catheterAssembly.add(basketGroup);
    catheterAssembly.add(specimenGroup);
    sceneR.add(catheterAssembly);

    // Position initiale de l'assemblage
    const assemblyRestPosition = { x: 0, y: 0, z: 0 };

    // État du drag
    let isDraggingCatheter = false;
    let dragStartMouse = { x: 0, y: 0 };
    let dragStartPosition = { y: 0, z: 0 };

    // Raycaster pour la scène droite (endoscopique)
    const raycasterR = new THREE.Raycaster();

    // Hitbox invisible pour le sheath (plus facile à cliquer)
    const sheathHitbox = new THREE.Mesh(
        new THREE.CylinderGeometry(1.2, 1.2, 14, 16),
        new THREE.MeshBasicMaterial({ visible: false })
    );
    sheathHitbox.rotation.z = Math.PI/2;
    sheathHitbox.position.x = -6;
    catheterAssembly.add(sheathHitbox);

    function updateNetGeometry(mesh, curveTop, curveSide, numSegments) {
        const topPoints = curveTop.getPoints(numSegments);
        const sidePoints = curveSide.getPoints(numSegments);
        const vertices = [];
        const indices = [];
        for (let i = 0; i <= numSegments; i++) {
            vertices.push(topPoints[i].x, topPoints[i].y, topPoints[i].z);
            vertices.push(sidePoints[i].x, sidePoints[i].y, sidePoints[i].z);
        }
        for (let i = 0; i < numSegments; i++) {
            const base = i * 2;
            indices.push(base, base + 1, base + 2);
            indices.push(base + 1, base + 3, base + 2);
        }
        mesh.geometry.dispose();
        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        geo.setIndex(indices);
        geo.computeVertexNormals();
        mesh.geometry = geo;
    }

    function updateVisuals() {
        handleA.slider.position.y = -3.5 + (state.hVert * 7);
        handleB.slider.position.y = -3.5 + (state.hHoriz * 7);
        basketGroup.position.x = (state.deploy - 1) * 7;

        const L = 5.5; const pts = 30; 
        
        // Arch
        const aH = state.hVert * 4.0;
        const aL = L - (state.hVert * 0.6);
        const aCurve = new THREE.CatmullRomCurve3([
            new THREE.Vector3(0,0,0), new THREE.Vector3(aL*0.2, aH*0.7, 0),
            new THREE.Vector3(aL*0.5, aH, 0), new THREE.Vector3(aL*0.8, aH*0.7, 0), new THREE.Vector3(aL,0,0)
        ]);
        archMesh.geometry.dispose();
        archMesh.geometry = new THREE.TubeGeometry(aCurve, pts*2, 0.12, 12, false);

        // Loops
        const wW = state.hHoriz * 3.5;
        const wL = L - (state.hHoriz * 0.3);
        const cL = new THREE.CatmullRomCurve3([
            new THREE.Vector3(0,0,0), new THREE.Vector3(wL*0.2, 0, wW*0.6),
            new THREE.Vector3(wL*0.5, 0, wW), new THREE.Vector3(wL*0.8, 0, wW*0.6), new THREE.Vector3(wL,0,0)
        ]);
        const cR = new THREE.CatmullRomCurve3([
            new THREE.Vector3(0,0,0), new THREE.Vector3(wL*0.2, 0, -wW*0.6),
            new THREE.Vector3(wL*0.5, 0, -wW), new THREE.Vector3(wL*0.8, 0, -wW*0.6), new THREE.Vector3(wL,0,0)
        ]);
        loopL.geometry.dispose(); loopL.geometry = new THREE.TubeGeometry(cL, pts*2, 0.05, 8, false);
        loopR.geometry.dispose(); loopR.geometry = new THREE.TubeGeometry(cR, pts*2, 0.05, 8, false);

        // Net
        updateNetGeometry(netMeshL, aCurve, cL, 20);
        updateNetGeometry(netMeshR, aCurve, cR, 20);

        // Physics
        if(!state.isEjected) {
            // Push Down Logic (when visible and inside)
            // Only apply if specimen is in "active" zone (REST_Y)
            if (specimenGroup.visible && Math.abs(specimenGroup.position.y - REST_Y) < 0.5) {
                let tY = REST_Y; 
                if(state.deploy > 0.9 && aH < (REST_Y + 0.5)) {
                    tY = Math.min(REST_Y, aH - 0.5); 
                }
                specimenGroup.position.y = tY;
            }

            if(state.deploy > 0.9 && state.hHoriz < 0.5) {
                const s = 1 - (state.hHoriz * 0.15);
                specimen.scale.set(s, 1, s);
            } else {
                specimen.scale.set(1, 1, 1);
            }
        }
    }

    // --- INTERACTION ---
    const raycaster = new THREE.Raycaster();

    // Mousedown - gère les deux viewports
    window.addEventListener('mousedown', (e) => {
        const split = window.innerWidth * 0.35;

        // Viewport gauche - handles
        if(e.clientX <= split) {
            const x = (e.clientX / split) * 2 - 1;
            const y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera({x, y}, cameraL);
            const hits = raycaster.intersectObjects(interactables);
            if(hits.length > 0) handleObjectClick(hits[0].object.userData.name);
            return;
        }

        // Viewport droit - drag cathéter uniquement en phase CARRY (3)
        if(currentPhase === 3) {
            const rightWidth = window.innerWidth - split;
            const x = ((e.clientX - split) / rightWidth) * 2 - 1;
            const y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycasterR.setFromCamera({x, y}, cameraR);
            const hits = raycasterR.intersectObjects([sheathHitbox, sheath, ...basketGroup.children]);
            if(hits.length > 0) {
                isDraggingCatheter = true;
                dragStartMouse = { x: e.clientX, y: e.clientY };
                dragStartPosition = { y: catheterAssembly.position.y, z: catheterAssembly.position.z };
                document.body.style.cursor = 'grabbing';
            }
        }
    });

    // Mousemove - gère hover et drag
    window.addEventListener('mousemove', (e) => {
        const split = window.innerWidth * 0.35;

        // Si on drag le cathéter
        if(isDraggingCatheter) {
            const deltaX = (e.clientX - dragStartMouse.x) * 0.02;
            const deltaY = (e.clientY - dragStartMouse.y) * 0.02;
            catheterAssembly.position.y = dragStartPosition.y - deltaY;
            catheterAssembly.position.z = dragStartPosition.z - deltaX; // Inversé pour correspondre au sens de la main
            // Limiter le mouvement
            catheterAssembly.position.y = Math.max(-3, Math.min(3, catheterAssembly.position.y));
            catheterAssembly.position.z = Math.max(-4, Math.min(4, catheterAssembly.position.z));
            return;
        }

        // Hover viewport gauche
        if(e.clientX <= split) {
            const x = (e.clientX / split) * 2 - 1;
            const y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera({x, y}, cameraL);
            const hits = raycaster.intersectObjects(interactables);
            document.body.style.cursor = hits.length > 0 ? 'pointer' : 'default';
            document.getElementById('tag-A').style.opacity = (hits.length && hits[0].object.userData.name === 'A') ? 1 : 0.6;
            document.getElementById('tag-B').style.opacity = (hits.length && hits[0].object.userData.name === 'B') ? 1 : 0.6;
            return;
        }

        // Hover viewport droit - cursor grab uniquement en phase CARRY
        if(currentPhase === 3) {
            const rightWidth = window.innerWidth - split;
            const x = ((e.clientX - split) / rightWidth) * 2 - 1;
            const y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycasterR.setFromCamera({x, y}, cameraR);
            const hits = raycasterR.intersectObjects([sheathHitbox, sheath, ...basketGroup.children]);
            document.body.style.cursor = hits.length > 0 ? 'grab' : 'default';
        } else {
            document.body.style.cursor = 'default';
        }
    });

    // Mouseup - fin du drag, retour à la position initiale
    window.addEventListener('mouseup', () => {
        if(isDraggingCatheter) {
            isDraggingCatheter = false;
            document.body.style.cursor = 'default';
            // Animation de retour à la position initiale
            gsap.to(catheterAssembly.position, {
                x: assemblyRestPosition.x,
                y: assemblyRestPosition.y,
                z: assemblyRestPosition.z,
                duration: 0.5,
                ease: "back.out(1.5)"
            });
        }
    });

    function handleObjectClick(handle) {
        if (state.deploy < 0.5) { triggerPhase(1); return; }

        // Logique basée sur la phase courante pour des transitions prévisibles
        if (currentPhase === 1) { // DEPLOY
            if (handle === 'A') triggerPhase(2); // → CAPTURE
            else if (handle === 'B') triggerPhase(5); // → WITHDRAW
        }
        else if (currentPhase === 2) { // CAPTURE
            if (handle === 'B') triggerPhase(3); // → CARRY
            else if (handle === 'A') triggerPhase(1); // → DEPLOY (retour)
        }
        else if (currentPhase === 3) { // CARRY
            if (handle === 'A') triggerPhase(4); // → RELEASE
            else if (handle === 'B') triggerPhase(2); // → CAPTURE (retour)
        }
        else if (currentPhase === 4) { // RELEASE
            if (handle === 'A') triggerPhase(1); // → DEPLOY
            else if (handle === 'B') triggerPhase(5); // → WITHDRAW
        }
        else { triggerPhase(1); } // Phase 5 (WITHDRAW) → DEPLOY
    }

    function triggerPhase(n) {
        // Mettre à jour la phase courante
        currentPhase = n;

        // Reset position cathéter si on quitte CARRY
        if(n !== 3) {
            gsap.to(catheterAssembly.position, { x: 0, y: 0, z: 0, duration: 0.3 });
        }

        document.querySelectorAll('.phase-btn').forEach(b => b.classList.remove('active'));
        document.getElementById(`btn-${n}`).classList.add('active');
        const title = document.getElementById('status-title');
        const desc = document.getElementById('status-desc');

        // VISIBILITY & POSITION LOGIC
        if (n === 5) {
            // 5. WITHDRAW: Instant Disappear
            specimenGroup.visible = false;
        } else if (n === 1) {
            // 1. DEPLOY: Stay Low (Out of way) but Visible if desired?
            // User asked for "conflict" avoidance -> Put it at LOW_Y
            specimenGroup.visible = true;
            gsap.to(specimenGroup.position, { y: LOW_Y, duration: 0.5 });
        } else if (n === 2) {
            // 2. CAPTURE: Move to Center (REST_Y) to be captured
            specimenGroup.visible = true;
            state.isEjected = false;
            gsap.to(specimenGroup.position, { y: REST_Y, duration: 0.8, ease: "back.out(1.2)" }); // Pop up into basket
        } else if (n === 3) {
            // 3. CARRY: Ensure at REST_Y
            specimenGroup.visible = true;
            state.isEjected = false;
            gsap.to(specimenGroup.position, { y: REST_Y, duration: 0.5 });
        } else if (n === 4) {
            // 4. RELEASE: Logic handled below (Eject)
            specimenGroup.visible = true;
        }

        if(n===1) {
            title.innerHTML = "1. DEPLOY";
            desc.innerHTML = "Device exits catheter. Polyp is below waiting.";
            // Deploy: Vert=0, Horiz=1
            gsap.to(state, { deploy: 1, hVert: 0, hHoriz: 1, duration: 1 });
        } else if(n===2) {
            title.innerHTML = "2. CAPTURE";
            desc.innerHTML = "Red Handle FWD. Arch rises, Polyp enters basket.";
            // Capture: Vert=1, Horiz=1
            gsap.to(state, { deploy: 1, hVert: 1, hHoriz: 1, duration: 1 });
        } else if(n===3) {
            title.innerHTML = "3. CARRY";
            desc.innerHTML = "Blue Handle BACK. Net closes around polyp.<br><span class='text-blue-400 text-xs'>Drag catheter to demonstrate carry motion.</span>";
            // Carry: Vert=1, Horiz=0.15
            gsap.to(state, { deploy: 1, hVert: 1, hHoriz: 0.15, duration: 1 });
        } else if(n===4) {
            title.innerHTML = "4. RELEASE";
            desc.innerHTML = "<b>Action:</b> Red Handle Pulled BACK. Piston Effect.";
            // Release: Vert=0, Horiz=1 (Fast)
            gsap.to(state, { hHoriz: 1, duration: 0.3 });
            gsap.to(state, { hVert: 0, delay: 0, duration: 0.4, ease: "back.in(1.5)", onStart: () => {
                state.isEjected = true;
                // Eject down to LOW_Y
                gsap.to(specimenGroup.position, { y: LOW_Y, duration: 0.6, ease: "power1.in" });
                gsap.to(specimen.rotation, { x: 3, z: 2, duration: 0.6 });
            }});
        } else if(n===5) {
            title.innerHTML = "5. WITHDRAW";
            desc.innerHTML = "System retracted.";
            // Withdraw: All 0
            gsap.to(state, { deploy: 0, hVert: 0, hHoriz: 0, duration: 1 });
        }
    }

    // Download Function
    function downloadSource() {
        const htmlContent = document.documentElement.outerHTML;
        const blob = new Blob([htmlContent], { type: 'text/html' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'dome_simulator_final.html';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    // Init
    window.addEventListener('resize', () => {
        const w = window.innerWidth; const h = window.innerHeight;
        renderer.setSize(w, h);
        cameraL.aspect = (w*0.35)/h; cameraL.updateProjectionMatrix();
        cameraR.aspect = (w*0.65)/h; cameraR.updateProjectionMatrix();
    });

    setTimeout(() => { document.getElementById('click-hint').style.opacity = 1; }, 1000);
    setTimeout(() => { document.getElementById('click-hint').style.opacity = 0; }, 5000);

    function render() {
        requestAnimationFrame(render);
        updateVisuals();
        if(!state.isEjected) specimen.rotation.y += 0.005;

        const w = window.innerWidth; const h = window.innerHeight; const s = w * 0.35;
        renderer.setViewport(0,0,s,h); renderer.setScissor(0,0,s,h); renderer.setScissorTest(true);
        renderer.render(sceneL, cameraL);
        renderer.setViewport(s,0,w-s,h); renderer.setScissor(s,0,w-s,h); renderer.setScissorTest(true);
        renderer.render(sceneR, cameraR);
    }

    triggerPhase(5); // Start withdrawn
    setTimeout(() => triggerPhase(1), 800);
    render();

</script>
</body>
</html>